/**
 * ^ {} : 변수 뒤에 할당되지 않으면 하나의 블록 변수 뒤에 할당되면 객체이다.
 * ^ let, const 전역으로 변수를 선언하고, {} 블록 스코프 안에서는 그 변수를 참조 하는건 상관 없다.
 * ^ 하지만 {} 블록스코프 안에서 변수를 선언하고 블록스코프 밖에서 호출하면 에러가 생긴다.
 * ? 그러나 var는 전역에 종속되기 때문에 상관이 없다. 하지만 var는 함수 스코프안에서는 갇혀서 전역으로 접근이 안된다. (생성하지 않는 것)
 * ? let, const는 함수에 갇혀서 밖에서 호출이 안되는게 아니라 원래 지역안에서 선언한 변수를 전역에서 호출하지 못한다.
 *
 */

/**
 * ! var는 변수 호이스팅 됨 선언단계 이전에 초기화단계를 거친다.
 * ! let, const는 변수 호이스팅이 되지만 초기화단계를 설정하지 않는다. 환경부가 다르기 때문에 선언 이전에 참조를 하게 되면 에러가 뜬다.
 * ! let, const는 TDZ 임시사각지역으로 들어가기 때문에 변수 선언 이전에 참조를 하게 되었을 시에 에러가 뜬다.
 * ! 변수는 변수명 함수는 본문 자체를 호이스팅 하기 때문 함수 선언 이전에 호출을 하면 함수 안에 있는 값이 전체적으로 호이스팅된다.
 *
 */

// function sum() {
//   let z = 3;
// }

// sum();

// console.log(z);

// ? 위 내용이 참조가 되지 않는 이유는 함수는 호출을 하면 종료가 되기 때문에 함수가 없는 상황이라 참조를 하지 못한다.

/* -------------------------------------------- */
/*                  Legacy var                  */
/* -------------------------------------------- */

// var로 선언한 변수의 스코프는 함수 스코프이거나 전역 스코프입니다.
// 블록 기준으로 스코프가 생기지 않기 때문에 블록 밖에서 접근 가능합니다.

// var outside = 'outer';

// {
//   console.log(outside);
// }

/**
 * 블록 스코프 안에서 전역 변수를 찾아나가는 것이 스코프체이닝
 */

// {
//   console.log(outside);
//   var outside = 'outer'; // undefined
// }

// {
//   var outside = 'outer';
// }
// console.log(outside); // var는 블록스코프의 영향을 받지 않는다. // outer

// ! 함수

// function a() {
//   var outside = 'outer'; // let을 사용해도 마찬가지
// }
// a();
// console.log(outside); // 에러 이유는 함수를 호출하고 함수가 종료되었기 때문에 값이 없어 호출할 수 있는 내용이 없다.

// ! let
{
  let outside = 'outer';
}

let outside = 'inner';

console.log(outside); // let,const는 블록스코프로 접근할 수 없다. // inner가 출력

// var는 변수의 중복 선언을 허용합니다
var b = 10;
// var b = 30;

console.log(b);

let c = 10;
{
  let c = 30;
}

console.log(c); // 10 let이 블록스코프에 있으면 접근을 하지 못하므로 전역에 선언 및 할당된 값이 참조된다.

// 선언하기 전 사용할 수 있는 var

console.log(d); // undefined
console.log(e); // error 이유는 let은 TDZ에 속해있기 때문에 변수 선언 이전에 참조가 먼저 실행되면 에러가 뜬다.
var d = 123456;
let e = 123456;
